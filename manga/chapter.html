<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Чтение главы</title>
  <style>
    body {
      margin: 0;
      font-family: "Roboto-Black", Helvetica, sans-serif;
      background-color: #0d1117;
      color: #fff;
      padding: 0;
      user-select: none;
    }

    .chapter-container {
      margin: 0;
      padding: 0;
    }

    .chapter-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0;
    }

    .chapter-page {
      width: 100%;
      max-width: 100%;
      height: auto;
      object-fit: contain;
      background: #000;
      display: block;
      margin: 0;
      padding: 0;
    }

    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 50vh;
      gap: 20px;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255,255,255,0.1);
      border-top: 3px solid #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .error {
      background: rgba(255, 59, 48, 0.1);
      border: 1px solid rgba(255, 59, 48, 0.3);
      border-radius: 12px;
      padding: 20px;
      color: #ff3b30;
      text-align: center;
      margin: 20px;
    }
  </style>
</head>
<body>
  <div class="chapter-container">
    <div id="loadingDiv" class="loading">
      <div class="loading-spinner"></div>
      <div>Загрузка главы...</div>
    </div>

    <div id="errorDiv" class="error" style="display: none;"></div>
    <div id="chapterContent" class="chapter-content" style="display: none;"></div>
  </div>

  <!-- Telegram Mini App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <script>
    const API_CONFIG = {
      baseUrl: 'https://nekros.tatokz2006.workers.dev',
      timeout: 15000
    };

    // Telegram Back Button
    if (window.Telegram && Telegram.WebApp) {
      Telegram.WebApp.ready();
      Telegram.WebApp.BackButton.show();
      Telegram.WebApp.BackButton.onClick(() => {
        // Переход назад внутри приложения
        if (document.referrer) {
          window.location.href = document.referrer;
        } else {
          window.history.back(); 
        }
      });
    }

    function getUrlParams() {
      const urlParams = new URLSearchParams(window.location.search);
      return {
        mangaId: urlParams.get('manga'),
        chapterId: urlParams.get('chapter')
      };
    }

    function showError(message) {
      document.getElementById('loadingDiv').style.display = 'none';
      document.getElementById('chapterContent').style.display = 'none';
      const errorDiv = document.getElementById('errorDiv');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
    }

    function createImageElement(imageSrc, container) {
      const img = document.createElement('img');
      img.className = 'chapter-page';
      img.alt = 'Страница';
      img.src = imageSrc;
      container.appendChild(img);
    }

    function displayChapterContent(chapterData) {
      const contentContainer = document.getElementById('chapterContent');
      contentContainer.innerHTML = '';

      const pages = (chapterData.chapterContent && chapterData.chapterContent.pages) || [];
      if (!pages.length) {
        showError('Страницы главы не найдены');
        return;
      }

      pages.forEach((pageUrl) => {
        if (pageUrl && pageUrl.trim()) {
          createImageElement(pageUrl.trim(), contentContainer);
        }
      });

      document.getElementById('loadingDiv').style.display = 'none';
      document.getElementById('chapterContent').style.display = 'flex';
    }

    async function fetchChapterData(mangaId, chapterId) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);
      const url = `${API_CONFIG.baseUrl}/?id=${mangaId}&cr=${chapterId}`;

      try {
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`Ошибка HTTP: ${response.status}`);
        return await response.json();
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }

    async function loadChapter() {
      const params = getUrlParams();
      if (!params.mangaId || !params.chapterId) {
        showError('Параметры главы не указаны в URL.');
        return;
      }

      try {
        const chapterData = await fetchChapterData(params.mangaId, params.chapterId);
        displayChapterContent(chapterData);
      } catch (error) {
        showError('Ошибка загрузки главы: ' + error.message);
      }
    }

    // Свайпы для смены главы
    let touchStartX = 0;
    let touchEndX = 0;
    let touchStartTime = 0;
    let startZone = ""; // "left" или "right"
    
    document.addEventListener("touchstart", (e) => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartTime = Date.now();
    
      const screenWidth = window.innerWidth;
      if (touchStartX < screenWidth * 0.15) {
        startZone = "left"; // левая сторона
      } else if (touchStartX > screenWidth * 0.85) {
        startZone = "right"; // правая сторона
      } else {
        startZone = "";
      }
    });
    
    document.addEventListener("touchend", (e) => {
      touchEndX = e.changedTouches[0].screenX;
      const deltaX = touchEndX - touchStartX;
      const duration = Date.now() - touchStartTime;
    
      // свайп засчитывается только если движение было длиннее 80px и длилось больше 150мс
      if (Math.abs(deltaX) > 80 && duration > 150) {
        if (deltaX > 0 && startZone === "left") {
          goToChapter("prev"); // свайп вправо с левого края → назад
        } else if (deltaX < 0 && startZone === "right") {
          goToChapter("next"); // свайп влево с правого края → вперёд
        }
      }
    });

  </script>
</body>
</html>
